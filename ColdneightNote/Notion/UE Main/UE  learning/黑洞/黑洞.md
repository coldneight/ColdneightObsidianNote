  

[Black hole with accretion disk (shadertoy.com)](https://www.shadertoy.com/view/tsBXW3)

![[Untitled.txt]]

  

\#define AA 2 //change to 1 to increase performance

\#define _Speed 3.0 //disk rotation speed

\#define _Steps 12. //disk texture layers  
\#define _Size 0.3 //size of BH

float hash(float x){ return fract(sin(x)*152754.742);}  
float hash(vec2 x){ return hash(x.x + hash(x.y));}

float value(vec2 p, float f) //value noise  
{  
float bl = hash(floor(p_f + vec2(0.,0.)));_  
_float br = hash(floor(p_f + vec2(1.,0.)));  
float tl = hash(floor(p_f + vec2(0.,1.)));_  
_float tr = hash(floor(p_f + vec2(1.,1.)));

```Plain
vec2 fr = fract(p*f);
fr = (3. - 2.*fr)*fr*fr;
float b = mix(bl, br, fr.x);
float t = mix(tl, tr, fr.x);
return  mix(b,t, fr.y);
```

}

vec4 background(vec3 ray)  
{  
vec2 uv = ray.xy;

```Plain
if( abs(ray.x) > 0.5)
    uv.x = ray.z;
else if( abs(ray.y) > 0.5)
    uv.y = ray.z;


float brightness = value( uv*3., 100.); //(poor quality) "stars" created from value noise
float color = value( uv*2., 20.);
brightness = pow(brightness, 256.);

brightness = brightness*100.;
brightness = clamp(brightness, 0., 1.);

vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);

vec4 nebulae = texture(iChannel0, (uv*1.5 ));
nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color
nebulae.xyz *= 0.25;

nebulae*= nebulae;
nebulae*= nebulae;
nebulae*= nebulae;
nebulae*= nebulae;

nebulae.xyz += stars;
return nebulae;
```

}

vec4 raymarchDisk(vec3 ray, vec3 zeroPos)  
{  
//return vec4(1.,1.,1.,0.); //no disk

```Plain
vec3 position = zeroPos;
float lengthPos = length(position.xz);
float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.4 *(1./_Steps) /( abs(ray.y) );

position += dist*_Steps*ray*0.5;

vec2 deltaPos;
deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;
deltaPos.y = zeroPos.x*0.01 + zeroPos.z;
deltaPos = normalize(deltaPos - zeroPos.xz);

float parallel = dot(ray.xz, deltaPos);
parallel /= sqrt(lengthPos);
parallel *= 0.5;
float redShift = parallel +0.3;
redShift *= redShift;

redShift = clamp(redShift, 0., 1.);

float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);
vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);

insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);
insideCol *= 1.25;
redShift += 0.12;
redShift *= redShift;

vec4 o = vec4(0.);

for(float i = 0. ; i < _Steps; i++)
{
    position -= dist * ray ;

    float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.);
    float lengthPos = length(position.xz);
    float distMult = 1.;

    distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);
    distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);
    distMult *= distMult;

    float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;

    vec2 xy ;
    float rot = mod(iTime*_Speed, 8192.);
    xy.x = -position.z*sin(rot) + position.x*cos(rot);
    xy.y = position.x*sin(rot) + position.z*cos(rot);

    float x = abs( xy.x/(xy.y));
	float angle = 0.02*atan(x);

    const float f = 70.;
    float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);
    noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);

    float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));

    float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);

    vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));
    o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));

    lengthPos *= (1./_Size);

    o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);
}

o.rgb = clamp(o.rgb - 0.005, 0., 1.);
return o ;
```

}

void Rotate( inout vec3 vector, vec2 angle )  
{  
vector.yz = cos(angle.y)*vector.yz  
+sin(angle.y)*vec2(-1,1)*vector.zy;  
vector.xz = cos(angle.x)*vector.xz  
+sin(angle.x)*vec2(-1,1)*vector.zx;  
}

void mainImage( out vec4 colOut, in vec2 fragCoord )  
{  
colOut = vec4(0.);;

```Plain
vec2 fragCoordRot;
fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;
fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;
fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;

for( int j=0; j<AA; j++ )
for( int i=0; i<AA; i++ )
{
    //setting up camera
    vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 ));
    vec3 pos = vec3(0.,0.05,-(20.*iMouse.xy/iResolution.y-10.)*(20.*iMouse.xy/iResolution.y-10.)*.05);
    vec2 angle = vec2(iTime*0.1,.2);
    angle.y = (2.*iMouse.y/iResolution.y)*3.14 + 0.1 + 3.14;
    float dist = length(pos);
    Rotate(pos,angle);
    angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);
    Rotate(ray,angle);

    vec4 col = vec4(0.);
    vec4 glow = vec4(0.);
    vec4 outCol =vec4(100.);

    for(int disks = 0; disks< 20; disks++) //steps
    {

        for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)
        {
            float dotpos = dot(pos,pos);
            float invDist = inversesqrt(dotpos); //1/distance to BH
            float centDist = dotpos * invDist; 	//distance to BH
            float stepDist = 0.92 * abs(pos.y /(ray.y));  //conservative distance to disk (y==0)
            float farLimit = centDist * 0.5; //limit step size far from to BH
            float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH
            stepDist = min(stepDist, min(farLimit, closeLimit));

            float invDistSqr = invDist * invDist;
            float bendForce = stepDist * invDistSqr * _Size * 0.625;  //bending force
            ray =  normalize(ray - (bendForce * invDist )*pos);  //bend ray towards BH
            pos += stepDist * ray;

            glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow
        }

        float dist2 = length(pos);

        if(dist2 < _Size * 0.1) //ray sucked in to BH
        {
            outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;
            break;
        }

        else if(dist2 > _Size * 1000.) //ray escaped BH
        {
            vec4 bg = background (ray);
            outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);
            break;
        }

        else if (abs(pos.y) <= _Size * 0.002 ) //ray hit accretion disk
        {
            vec4 diskCol = raymarchDisk(ray, pos);   //render disk
            pos.y = 0.;
            pos += abs(_Size * 0.001 /ray.y) * ray;
            col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));
        }
    }

    //if the ray never escaped or got sucked in
    if(outCol.r == 100.)
        outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);

    col = outCol;
    col.rgb =  pow( col.rgb, vec3(0.6) );

    colOut += col/float(AA*AA);
}
```

}

  

```Plain
\#define AA 2  //change to 1 to increase performance

\#define _Speed 3.0  //disk rotation speed

\#define _Steps  12. //disk texture layers
\#define _Size 0.3 //size of BH

float hash(float x){ return fract(sin(x)*152754.742);}
float hash(vec2 x){	return hash(x.x + hash(x.y));}

float value(vec2 p, float f) //value noise
{
float bl = hash(floor(p*f + vec2(0.,0.)));
float br = hash(floor(p*f + vec2(1.,0.)));
float tl = hash(floor(p*f + vec2(0.,1.)));
float tr = hash(floor(p*f + vec2(1.,1.)));

vec2 fr = fract(p*f);
fr = (3. - 2.*fr)*fr*fr;
float b = mix(bl, br, fr.x);
float t = mix(tl, tr, fr.x);
return  mix(b,t, fr.y);

}

vec4 background(vec3 ray)
{
vec2 uv = ray.xy;

if( abs(ray.x) > 0.5)
    uv.x = ray.z;
else if( abs(ray.y) > 0.5)
    uv.y = ray.z;

float brightness = value( uv*3., 100.); //(poor quality) "stars" created from value noise
float color = value( uv*2., 20.);
brightness = pow(brightness, 256.);

brightness = brightness*100.;
brightness = clamp(brightness, 0., 1.);

vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);

vec4 nebulae = texture(iChannel0, (uv*1.5 ));
nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color
nebulae.xyz *= 0.25;

nebulae*= nebulae;
nebulae*= nebulae;
nebulae*= nebulae;
nebulae*= nebulae;

nebulae.xyz += stars;
return nebulae;

}

vec4 raymarchDisk(vec3 ray, vec3 zeroPos)
{
vec3 position = zeroPos;
float lengthPos = length(position.xz);
float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.4 *(1./_Steps) /( abs(ray.y) );

position += dist*_Steps*ray*0.5;

vec2 deltaPos;
deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;
deltaPos.y = zeroPos.x*0.01 + zeroPos.z;
deltaPos = normalize(deltaPos - zeroPos.xz);

float parallel = dot(ray.xz, deltaPos);
parallel /= sqrt(lengthPos);
parallel *= 0.5;
float redShift = parallel +0.3;
redShift *= redShift;

redShift = clamp(redShift, 0., 1.);

float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);
vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);

insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);
insideCol *= 1.25;
redShift += 0.12;
redShift *= redShift;

vec4 o = vec4(0.);

for(float i = 0. ; i < _Steps; i++)
{
    position -= dist * ray ;

    float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.);
    float lengthPos = length(position.xz);
    float distMult = 1.;

    distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);
    distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);
    distMult *= distMult;

    float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;

    vec2 xy ;
    float rot = mod(iTime*_Speed, 8192.);
    xy.x = -position.z*sin(rot) + position.x*cos(rot);
    xy.y = position.x*sin(rot) + position.z*cos(rot);

    float x = abs( xy.x/(xy.y));
	float angle = 0.02*atan(x);

    const float f = 70.;
    float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);
    noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);

    float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));

    float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);

    vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));
    o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));

    lengthPos *= (1./_Size);

    o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);
}

o.rgb = clamp(o.rgb - 0.005, 0., 1.);
return o ;

}

void mainImage( out vec4 colOut, in vec2 fragCoord )
{
colOut = vec4(0.);;

vec2 fragCoordRot;
fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;
fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;
fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;

for( int j=0; j<AA; j++ )
for( int i=0; i<AA; i++ )
{
    //setting up camera
    vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 ));
    vec3 pos = vec3(0.,0.05,-(20.*iMouse.xy/iResolution.y-10.)*(20.*iMouse.xy/iResolution.y-10.)*.05);
    vec2 angle = vec2(iTime*0.1,.2);
    angle.y = (2.*iMouse.y/iResolution.y)*3.14 + 0.1 + 3.14;
    float dist = length(pos);
    Rotate(pos,angle);
    angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);
    Rotate(ray,angle);

    vec4 col = vec4(0.);
    vec4 glow = vec4(0.);
    vec4 outCol =vec4(100.);

    for(int disks = 0; disks< 20; disks++) //steps
    {

        for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)
        {
            float dotpos = dot(pos,pos);
            float invDist = inversesqrt(dotpos); //1/distance to BH
            float centDist = dotpos * invDist; 	//distance to BH
            float stepDist = 0.92 * abs(pos.y /(ray.y));  //conservative distance to disk (y==0)
            float farLimit = centDist * 0.5; //limit step size far from to BH
            float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH
            stepDist = min(stepDist, min(farLimit, closeLimit));

            float invDistSqr = invDist * invDist;
            float bendForce = stepDist * invDistSqr * _Size * 0.625;  //bending force
            ray =  normalize(ray - (bendForce * invDist )*pos);  //bend ray towards BH
            pos += stepDist * ray;

            glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow
        }

        float dist2 = length(pos);

        if(dist2 < _Size * 0.1) //ray sucked in to BH
        {
            outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;
            break;
        }

        else if(dist2 > _Size * 1000.) //ray escaped BH
        {
            vec4 bg = background (ray);
            outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);
            break;
        }

        else if (abs(pos.y) <= _Size * 0.002 ) //ray hit accretion disk
        {
            vec4 diskCol = raymarchDisk(ray, pos);   //render disk
            pos.y = 0.;
            pos += abs(_Size * 0.001 /ray.y) * ray;
            col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));
        }
    }

    //if the ray never escaped or got sucked in
    if(outCol.r == 100.)
        outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);

    col = outCol;
    col.rgb =  pow( col.rgb, vec3(0.6) );

    colOut += col/float(AA*AA);
}

}
```

# 黑洞

## 简介

这个着色器实现的是一个黑洞的图像，包括黑洞周围的吸积盘和光环。这个着色器使用的是Raymarching技术，渲染黑洞的时候，我们将光线以及黑洞周围的物体都看做是一个个粒子，然后用求交的方式，计算出每个光线与粒子的交点，从而得到渲染出来的图像。这个着色器的实现过程相对复杂，需要仔细分析。

## 贡献者

这个着色器是由Inigo Quilez和Dave Hoskins合作完成的。

## 如何使用

这个着色器可以直接在Shadertoy网站上运行，也可以下载到本地进行修改。

## 代码分析

### 基本框架

这个着色器的渲染函数是`mainImage()`。它的输入是当前像素的坐标`fragCoord`，以及传递进来的一些变量，如当前时间`iTime`、鼠标的位置`iMouse`、屏幕分辨率`iResolution`等。输出是当前像素的颜色值`colOut`。

这个渲染函数的主要作用是对每个像素进行处理，计算出该像素的颜色值。渲染函数使用了两个嵌套的循环，对每个像素进行抗锯齿处理。

## 着色器参数

这个着色器包含了许多参数，这些参数可以直接在代码中修改，以得到不同的效果。以下是一些重要参数的说明：

- `AA`：抗锯齿采样的数量。通常情况下，这个值的范围为1到4之间。
- `_Speed`：吸积盘的旋转速度。这个值越大，盘的旋转速度越快。
- `_Steps`：吸积盘的层数，即吸积盘的厚度。这个值越大，渲染出来的盘就越厚。
- `_Size`：黑洞的大小。这个值越大，黑洞的直径就越大。

## 基本着色器实现

这个着色器的主要实现是基于Raymarching技术的。Raymarching是一种基于光线追踪的技术，可以用来渲染复杂的三维场景。Raymarching会从摄像机发出一条光线，一直延伸到场景中的物体，然后计算光线与物体的交点，从而得到渲染出来的图像。

在这个着色器中，我们使用了Raymarching来渲染黑洞周围的吸积盘和光环。具体来说，我们将每个光线看做是一个粒子，然后用求交的方式，计算出每个光线与粒子的交点，从而得到渲染出来的图像。

## 黑洞的实现

黑洞的实现是这个着色器的核心。黑洞的实现是通过对光线进行迭代计算来实现的。具体来说，我们将光线沿着其方向推进一定的步长，然后计算出新的光线方向，再用新的光线方向进行下一次迭代。这个过程会一直持续下去，直到光线被吸收到黑洞中或者逃离黑洞的引力范围。

## 吸积盘的实现

吸积盘是黑洞周围的一种物质环，由大量的气体和尘埃组成。吸积盘的形状通常是平坦的，并且沿着黑洞的赤道平面。吸积盘的形状和颜色都会随着黑洞自转而发生变化。

在这个着色器中，我们使用了Raymarching技术来渲染吸积盘。具体来说，我们将吸积盘看做是由多层圆盘组成的，然后用求交的方式来计算光线与圆盘的交点。

## 光环的实现

光环是黑洞周围的一种辐射带，由高能粒子组成，通常呈现出弧形或环形。光环的颜色和形状也会随着黑洞自转而发生变化。

在这个着色器中，我们使用了一种比较简单的方式来渲染光环，即通过在渲染黑洞的同时，计算光线与粒子的距离以及角度，从而得到光环的效果。